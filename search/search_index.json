{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Arsh24's Writeups","text":""},{"location":"#2023","title":"2023","text":"<p>HackTheBox CyberApocalypse 2023</p>"},{"location":"2023/HTB-Cyber-Apocalypse/","title":"Cyber Apocalypse 2023 - The Cursed Mission","text":"<ul> <li>Link: Cyber Apocalypse 2023</li> <li>Date: 18.03.2023 - 23.03.2023</li> <li>Team: ZZ_F5</li> </ul>"},{"location":"2023/HTB-Cyber-Apocalypse/#team-score","title":"Team Score","text":""},{"location":"2023/HTB-Cyber-Apocalypse/#writeups","title":"Writeups","text":"<p>Hardware [5/5]</p> <ol> <li>Timed Transmission</li> <li>Critical Flight</li> <li>Debug</li> <li>Secret Code</li> <li>HM74</li> </ol>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/critical-flight/","title":"Critical Flight","text":"<ul> <li>Difficulty: Very Easy</li> <li>Files: hw_critical_flight.zip</li> </ul>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/critical-flight/#analysis","title":"Analysis","text":"<p>The folder downloaded have many files with the .gbr extension. This extension is for Gerber format, a vector format for printed circuit board (PCB). All these images are the layers of a PCB.</p> <p>Open these files in gerbv: <code>sudo apt install gerbv</code></p> <p>Now, we analyse each layer.</p> <p>On the first layer, we can see the begin of the flag:</p> <p></p> <p>And the end of the flag:</p> <p></p> <p>Flag: HTB{533_7h3_1nn32_w02k1n95_0f_313c720n1c5#$@}</p>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/debug/","title":"Debug","text":"<ul> <li>Difficulty: Easy</li> <li>Files: hw_debug.zip</li> </ul>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/debug/#analysis","title":"Analysis","text":"<p>Like the first hardware's challenge, we have a .sal file.</p> <p>Let's open it with Logic2</p> <p></p> <p>When opening the file, we can see signals on RX (receiver) but nothing on TX (transmiter). It is probably a reception of debug messages (name of the challenge).</p> <p>If we zoom in on a signal, we can see other variations, so we will analyze them.</p> <p></p> <p>On the Analyzers tab, we configure an analyze Async Serial with 9800 bauds(bits/s).</p> <p></p> <p>We can now see data. I have decided to export it and analyse it with python.</p> <p>This is the output of Logic2:</p> <pre><code>Async Serial    data    0x49\nAsync Serial    data    0x4E\nAsync Serial    data    0x46\nAsync Serial    data    0x4F\nAsync Serial    data    0x3A\n</code></pre> <p>We have to extract the hex and convert it in ascii, my python code:</p> <pre><code>with open(\"data.txt\", \"r\") as f:\n    data = f.readlines()\n    debug = \"\"\n    for line in data:\n        debug += chr(int(line.split(\"   \")[-1][2:], 16))\n    print(debug)\n</code></pre> <p>After that we have all the debug messages :</p> <p></p> <p>The flag is split on the 4 lines of Galaxy Gateway Network Information.</p> <p>Flag: HTB{547311173_n37w02k_c0mp20m153d}</p>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/hm74/","title":"HM74","text":"<ul> <li>Difficulty: Medium</li> <li>Files: hw_hm74.zip</li> <li>Server : IP:PORT</li> </ul>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/hm74/#analysis","title":"Analysis","text":"<p>The file provided to us has a .sv extension, so it is a Verilog file.</p> <pre><code>module encoder(\n    input [3:0] data_in,\n    output [6:0] ham_out\n    );\n\n    wire p0, p1, p2;\n\n    assign p0 = data_in[3] ^ data_in[2] ^ data_in[0];\n    assign p1 = data_in[3] ^ data_in[1] ^ data_in[0];\n    assign p2 = data_in[2] ^ data_in[1] ^ data_in[0];\n\n    assign ham_out = {p0, p1, data_in[3], p2, data_in[2], data_in[1], data_in[0]};\nendmodule\n\nmodule main;\n    wire[3:0] data_in = 5;\n    wire[6:0] ham_out;\n\n    encoder en(data_in, ham_out);\n\n    initial begin\n        #10;\n        $display(\"%b\", ham_out);\n    end\nendmodule\n</code></pre> <p>There are two modules inside, a main and an encoder.</p> <p>The encoder takes a 4-bit input data data_in, and returns a 7-bit data ham_out. It is in fact a Hamming 4/7 encoding. </p> <p>Now, let's see what the server sends us.</p> <p><code>nc $IP $PORT</code></p> <pre><code>Captured: 01010001100000110010[...]\nCaptured: 10110001110001010010[...]\nCaptured: 10010001110100010010[...]\nCaptured: 10011001010001000000[...]\n</code></pre> <p>We notice that the server sends very long binary strings in loop and always different between them. These strings are actually noisy, so the objective of this challenge is to use hamming decoding to correct the errors as much as possible by using the parity bits.  I let you google for more details about this encoding / decoding.</p> <p>Here is the hamming decoding function in python that I used:</p> <pre><code>def hamming_decode(bits):\n    # Computed the parity bits\n    p0 = bits[0] ^ bits[2] ^ bits[4] ^ bits[6]\n    p1 = bits[1] ^ bits[2] ^ bits[5] ^ bits[6]\n    p2 = bits[3] ^ bits[4] ^ bits[5] ^ bits[6]\n\n    # Determine the position of the error (if any)\n    error_pos = p0 + p1 * 2 + p2 * 4 - 1\n\n    # Correct the error if it is present\n    if error_pos &gt;= 0:\n        return \"\"\n    else:\n        # Return the decoded data bits\n        return \"\".join([str(bit) for bit in (bits[2], bits[4], bits[5], bits[6])])\n</code></pre> <p>Then, it is enough to cut the binary strings every 7 bits, to decode them to have 4 bits and to group on 8 bits to convert in ascii. By using a little analysis to get the right character in case of undetected error, we can determine the flag.</p> <p>Flag: HTB{hmm_w1th_s0m3_ana1ys15_y0u_c4n_3x7ract_7h3_h4mmin9_7_4_3nc_fl49}</p>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/secret-code/","title":"Secret Code","text":"<ul> <li>Difficulty: Easy</li> <li>Files: hw_secret_code.zip</li> </ul>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/secret-code/#analysis","title":"Analysis","text":"<p>Let's open the files. There are a saleae file and a lot of gbr.</p> <p>So we open the saleae file with Logic2.</p> <p></p> <p>There are 8 channels and the number 1 look like a clock. Let's open all the PCB layer with gerbv to correlate it with these signals.</p> <p></p> <p>At this point we have unkown signals and a weird pcb, but we can see three elements, one on the center of the eye, one on the left and the other on the right. We have to zoom to analyse.</p> <p></p> <p>On the center, we can see a 7 segments display. So we can deduce that the signals ont the saleae file are the inputs of this display. We just have to know which signal is connected to which pin.</p> <p></p> <p></p> <p>On the other two elements, you can see the numbering of the signals. Here are the different connections :</p> <p></p> <p>Now you just have to match these entries with the signals in the saleae file to see what is displayed. Then you get a hexadecimal string : </p> <p>\"4854427b70307733325f63306d33355f6632306d5f77313768316e4021237\"</p> <p>Just decode this to get the flag.</p> <p>Flag: HTB{p0w32_c0m35_f20m_w17h1n@!#}</p>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/timed-transmission/","title":"Timed Transmission","text":"<ul> <li>Difficulty: Very Easy</li> <li>Files: hw_timed_transmission.zip</li> </ul>"},{"location":"2023/HTB-Cyber-Apocalypse/hardware/timed-transmission/#analysis","title":"Analysis","text":"<p>The file for this challenge has a .sal extension.</p> <p>After some searches on google, we found the software Logic 2 from Saleae. It is a logic analyzer for debugging electronic hardware.</p> <p></p> <p>Here, the signals directly form the letters of the flag. </p> <p>Flag : HTB{b391N_tH3_HArdWAr3_QU3St}</p>"}]}